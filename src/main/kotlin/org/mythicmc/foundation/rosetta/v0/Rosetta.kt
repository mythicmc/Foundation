package org.mythicmc.foundation.rosetta.v0

import net.kyori.adventure.text.Component
import net.kyori.adventure.text.format.NamedTextColor
import net.kyori.adventure.text.format.TextColor
import net.kyori.adventure.text.minimessage.MiniMessage
import net.kyori.adventure.text.minimessage.tag.Tag
import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder
import net.kyori.adventure.text.minimessage.tag.resolver.TagResolver
import org.mythicmc.foundation.platform.v0.Platform
import java.util.EnumMap

/**
 * Provides functions to retrieve system message prefixes, which are common to all system messages
 * generated by server plugins, as well as the colour scheme for various types of system messages.
 * These types are defined in [MessageType].
 *
 * The colour scheme and prefix formats are configurable in the `rosetta-v0/prefix.yml` file, stored
 * in the Foundation plugin's data folder.
 */
object Rosetta {
    /**
     * Uses [Rosetta.prefix] to resolve Adventure MiniMessage tags in the following formats:
     * - `<prefix:[MessageType]>` e.g. `<prefix:info>`
     * - `<prefix:[MessageType]:prefix_content>` e.g. `<prefix:warning:Alert>`
     * - `<prefix:prefix_color:prefix_content>` e.g. `<prefix:black:"Beware!">`
     */
    val PREFIX_TAG_RESOLVER = TagResolver.resolver("prefix") { queue, context -> Tag.inserting {
        val typeOrColor = queue.popOr(
            "<red><bold>Internal Error:</bold> A prefix MUST have either have a type or color + content!"
        )
        try {
            val type = MessageType.valueOf(typeOrColor.lowerValue().uppercase())
            return@inserting if (queue.hasNext())
                prefix(type, queue.pop().value())
            else
                prefix(type)
        } catch (_: IllegalArgumentException) {
            val color = parseColor(typeOrColor.lowerValue()) ?:
            return@inserting MiniMessage.miniMessage().deserialize(
                "<red><bold>Internal Error:</bold> Invalid prefix type or color specified!"
            )

            return@inserting prefix(color, queue.popOr(
                "<red><bold>Internal Error:</bold> A prefix without a type must have content!"
            ).value())
        }
    } }

    private lateinit var PREFIX: String
    private val COLOR_SCHEME = EnumMap<MessageType, TextColor>(MessageType::class.java)

    internal fun loadPrefixYml(platform: Platform) {
        // FIXME: Save default prefix.yml
    }

    private fun parseColor(color: String): TextColor? =
        NamedTextColor.NAMES.value(color.uppercase()) ?: TextColor.fromHexString(color)

    /**
     * Returns the color defined in the color scheme for a certain type of system message. e.g. for
     * [MessageType.ERROR], it may return a shade of red.
     *
     * Plugin developers are recommended to use these colors for uniformity across plugins.
     *
     * @see Rosetta
     * @param type the type of system message
     * @return the color for such system messages as a [TextColor]
     */
    fun color(type: MessageType): TextColor =
        COLOR_SCHEME[type] ?: throw IllegalArgumentException("Invalid MessageType")

    /**
     * Returns a prefix for system messages, with a uniform format and color scheme for consistency
     * across plugins. The prefix is returned as a [Component].
     *
     * This overload sets the text inside the prefix to the message type (e.g. `Info` for
     * [MessageType.INFO]), and the prefix color is set according to the color scheme for the
     * message type (e.g. `red` for errors, `yellow` for warnings, etc.)
     *
     * @see Rosetta
     * @param type the type of system message
     * @return the prefix as a [Component] to prepend to your system message
     */
    fun prefix(type: MessageType): Component =
        prefix(color(type),
            Component.text(type.name.lowercase().replaceFirstChar { it.titlecase() }))

    /**
     * Returns a prefix for system messages, with a uniform format and color scheme for consistency
     * across plugins. The prefix is returned as a [Component].
     *
     * This overload accepts the text within the prefix (e.g. `Info`, `Success`, `Error`, etc.) in
     * MiniMessage format. The prefix color is set according to the color scheme for the message
     * type (e.g. `red` for errors, `yellow` for warnings, etc.)
     *
     * @see Rosetta
     * @param type the type of system message
     * @param content text to include within the prefix, e.g. Info, in MiniMessage format
     * @return the prefix as a [Component] to prepend to your system message
     */
    fun prefix(type: MessageType, content: String): Component =
        prefix(color(type), content)

    /**
     * Returns a prefix for system messages, with a uniform format and color scheme for consistency
     * across plugins. The prefix is returned as a [Component].
     *
     * This overload accepts the text within the prefix (e.g. `Info`, `Success`, `Error`, etc.) as
     * a [Component]. The prefix color is set according to the color scheme for the message type
     * (e.g. `red` for errors, `yellow` for warnings, etc.)
     *
     * @see Rosetta
     * @param type the type of system message
     * @param content text to include within the prefix, e.g. Info, as a [Component]
     * @return the prefix as a [Component] to prepend to your system message
     */
    fun prefix(type: MessageType, content: Component): Component =
        prefix(color(type), content)

    /**
     * Returns a prefix for system messages, with a uniform format and color scheme for consistency
     * across plugins. The prefix is returned as a [Component].
     *
     * This overload accepts the text within the prefix (e.g. `Info`, `Success`, `Error`, etc.) in
     * MiniMessage format, and the prefix color (e.g. `red` for errors, `yellow` for warnings, etc.)
     *
     * Note: Prefer using the [MessageType] functions over specifying your own colors, to enable
     * consistency across all system messages on the server.
     *
     * @see Rosetta
     * @param color the color of the prefix (should match the intent and content of the message)
     * @param content text to include within the prefix, e.g. Info, in MiniMessage format
     * @return the prefix as a [Component] to prepend to your system message
     */
    fun prefix(color: TextColor, content: String): Component =
        MiniMessage.miniMessage().deserialize(PREFIX,
            Placeholder.styling("prefix_color", color),
            Placeholder.parsed("prefix_content", content))

    /**
     * Returns a prefix for system messages, with a uniform format and color scheme for consistency
     * across plugins. The prefix is returned as a [Component].
     *
     * This overload accepts the text within the prefix (e.g. `Info`, `Success`, `Error`, etc.) as
     * a [Component], and the prefix color (e.g. `red` for errors, `yellow` for warnings, etc.)
     *
     * Note: Prefer using the [MessageType] functions over specifying your own colors, to enable
     * consistency across all system messages on the server.
     *
     * @see Rosetta
     * @param color the color of the prefix (should match the intent and content of the message)
     * @param content text to include within the prefix, e.g. Info, as a [Component]
     * @return the prefix as a [Component] to prepend to your system message
     */
    fun prefix(color: TextColor, content: Component): Component =
        MiniMessage.miniMessage().deserialize(PREFIX,
            Placeholder.styling("prefix_color", color),
            Placeholder.component("prefix_content", content))

    // FIXME: legacyPrefix and rawPrefix equivalents
}
