package org.mythicmc.foundation.rosetta.v0

import net.kyori.adventure.text.Component
import net.kyori.adventure.text.format.NamedTextColor
import net.kyori.adventure.text.format.TextColor
import net.kyori.adventure.text.minimessage.MiniMessage
import net.kyori.adventure.text.minimessage.tag.Tag
import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder
import net.kyori.adventure.text.minimessage.tag.resolver.TagResolver
import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer
import org.mythicmc.foundation.platform.v0.Platform
import org.yaml.snakeyaml.Yaml
import java.nio.file.Files
import java.util.EnumMap
import kotlin.io.path.createDirectories
import kotlin.io.path.exists
import kotlin.io.path.reader

/**
 * Provides functions to retrieve system message prefixes, which are common to all system messages
 * generated by server plugins, as well as the colour scheme for various types of system messages.
 * These types are defined in [MessageType].
 *
 * The colour scheme and prefix formats are configurable in the `rosetta-v0/prefix.yml` file, stored
 * in the Foundation plugin's data folder.
 */
object Rosetta {
    private lateinit var PREFIX: String
    private val COLOR_SCHEME = EnumMap<MessageType, TextColor>(MessageType::class.java)

    // TODO: Maybe Foundation should include Kaml/kotlinx.serialisation
    internal data class PrefixYaml(var prefix: String = "", var color_scheme: Map<String, String> = hashMapOf())

    internal fun loadPrefixYml(platform: Platform) {
        val dataFolder = platform.dataDirectory.resolve("rosetta-v0")
        if (!dataFolder.exists())
            dataFolder.createDirectories()
        val prefixFilePath = dataFolder.resolve("prefix.yml")
        val prefixFileExists = prefixFilePath.exists()
        if (!prefixFileExists) {
            Files.copy(platform.getResource("rosetta-v0/prefix.yml")!!, prefixFilePath)
        }

        val correctClassLoader = PrefixYaml::class.java.classLoader
        val originalClassLoader = Thread.currentThread().contextClassLoader
        val parsedYaml: PrefixYaml = try {
            Thread.currentThread().contextClassLoader = correctClassLoader
            Yaml().loadAs(prefixFilePath.reader(), PrefixYaml::class.java)
        } finally {
            Thread.currentThread().contextClassLoader = originalClassLoader
        }

        PREFIX = parsedYaml.prefix
        for (type in MessageType.entries) {
            val colorName = parsedYaml.color_scheme[type.name.lowercase()] ?:
            throw IllegalArgumentException("No color specified for `${type.name.lowercase()}` in `rosetta-v0/prefix.yml`")

            COLOR_SCHEME[type] = parseColor(colorName) ?:
            throw IllegalArgumentException("Unknown color `$colorName` specified for `${type.name.lowercase()}` in `rosetta-v0/prefix.yml`")
        }
    }

    private fun parseColor(color: String): TextColor? =
        NamedTextColor.NAMES.value(color.lowercase()) ?: TextColor.fromHexString(color)

    /**
     * Uses [Rosetta.prefix] to resolve Adventure MiniMessage tags in the following formats:
     * - `<prefix:[MessageType]>` e.g. `<prefix:info>`
     * - `<prefix:[MessageType]:prefix_content>` e.g. `<prefix:warning:Alert>`
     * - `<prefix:prefix_color:prefix_content>` e.g. `<prefix:black:"Beware!">`
     */
    val PREFIX_TAG_RESOLVER = TagResolver.resolver("prefix") { queue, context -> Tag.inserting {
        val typeOrColor = queue.popOr(
            "<red><bold>Internal Error:</bold> A prefix MUST have either have a type or color + content!"
        )
        try {
            val type = MessageType.valueOf(typeOrColor.lowerValue().uppercase())
            return@inserting if (queue.hasNext())
                prefix(type, queue.pop().value())
            else
                prefix(type)
        } catch (_: IllegalArgumentException) {
            val color = parseColor(typeOrColor.lowerValue()) ?:
            return@inserting MiniMessage.miniMessage().deserialize(
                "<red><bold>Internal Error:</bold> Invalid prefix type or color specified!"
            )

            return@inserting prefix(color, queue.popOr(
                "<red><bold>Internal Error:</bold> A prefix without a type must have content!"
            ).value())
        }
    } }

    /**
     * Returns the color defined in the color scheme for a certain type of system message. e.g. for
     * [MessageType.ERROR], it may return a shade of red.
     *
     * Plugin developers are recommended to use these colors for uniformity across plugins.
     *
     * @see Rosetta
     * @param type the type of system message
     * @return the color for such system messages as a [TextColor]
     */
    fun color(type: MessageType): TextColor =
        COLOR_SCHEME[type] ?: throw IllegalArgumentException("Invalid MessageType")

    /**
     * Returns the raw prefix for system messages in MiniMessage format, with none of the
     * placeholders substituted. You typically want to use one of the [prefix] functions instead.
     *
     * Placeholders in the raw prefix string are:
     * - `<prefix_content>` is a short text conveying the intent of the message e.g. Info, Error,
     *   Success, Warning, etc.
     * - `<prefix_color>` is the colour of the prefix, typically corresponding to the message
     *   intent, e.g. red for errors, green for success, yellow for warning, etc.
     *
     * @see Rosetta
     * @return the raw prefix in MiniMessage format
     */
    fun rawPrefix(): String = PREFIX

    /**
     * Returns a prefix for system messages, with a uniform format and color scheme for consistency
     * across plugins. The prefix is returned as a [Component].
     *
     * This overload sets the text inside the prefix to the message type (e.g. `Info` for
     * [MessageType.INFO]), and the prefix color is set according to the color scheme for the
     * message type (e.g. `red` for errors, `yellow` for warnings, etc.)
     *
     * @see Rosetta
     * @param type the type of system message
     * @return the prefix as a [Component] to prepend to your system message
     */
    fun prefix(type: MessageType): Component =
        prefix(color(type),
            Component.text(type.name.lowercase().replaceFirstChar { it.titlecase() }))

    /**
     * Returns a prefix for system messages, with a uniform format and color scheme for consistency
     * across plugins. The prefix is returned as a [Component].
     *
     * This overload accepts the text within the prefix (e.g. `Info`, `Success`, `Error`, etc.) in
     * MiniMessage format. The prefix color is set according to the color scheme for the message
     * type (e.g. `red` for errors, `yellow` for warnings, etc.)
     *
     * @see Rosetta
     * @param type the type of system message
     * @param content text to include within the prefix, e.g. Info, in MiniMessage format
     * @return the prefix as a [Component] to prepend to your system message
     */
    fun prefix(type: MessageType, content: String): Component =
        prefix(color(type), content)

    /**
     * Returns a prefix for system messages, with a uniform format and color scheme for consistency
     * across plugins. The prefix is returned as a [Component].
     *
     * This overload accepts the text within the prefix (e.g. `Info`, `Success`, `Error`, etc.) as
     * a [Component]. The prefix color is set according to the color scheme for the message type
     * (e.g. `red` for errors, `yellow` for warnings, etc.)
     *
     * @see Rosetta
     * @param type the type of system message
     * @param content text to include within the prefix, e.g. Info, as a [Component]
     * @return the prefix as a [Component] to prepend to your system message
     */
    fun prefix(type: MessageType, content: Component): Component =
        prefix(color(type), content)

    /**
     * Returns a prefix for system messages, with a uniform format and color scheme for consistency
     * across plugins. The prefix is returned as a [Component].
     *
     * This overload accepts the text within the prefix (e.g. `Info`, `Success`, `Error`, etc.) in
     * MiniMessage format, and the prefix color (e.g. `red` for errors, `yellow` for warnings, etc.)
     *
     * Note: Prefer using the [MessageType] functions over specifying your own colors, to enable
     * consistency across all system messages on the server.
     *
     * @see Rosetta
     * @param color the color of the prefix (should match the intent and content of the message)
     * @param content text to include within the prefix, e.g. Info, in MiniMessage format
     * @return the prefix as a [Component] to prepend to your system message
     */
    fun prefix(color: TextColor, content: String): Component =
        MiniMessage.miniMessage().deserialize(PREFIX,
            Placeholder.styling("prefix_color", color),
            Placeholder.parsed("prefix_content", content))

    /**
     * Returns a prefix for system messages, with a uniform format and color scheme for consistency
     * across plugins. The prefix is returned as a [Component].
     *
     * This overload accepts the text within the prefix (e.g. `Info`, `Success`, `Error`, etc.) as
     * a [Component], and the prefix color (e.g. `red` for errors, `yellow` for warnings, etc.)
     *
     * Note: Prefer using the [MessageType] functions over specifying your own colors, to enable
     * consistency across all system messages on the server.
     *
     * @see Rosetta
     * @param color the color of the prefix (should match the intent and content of the message)
     * @param content text to include within the prefix, e.g. Info, as a [Component]
     * @return the prefix as a [Component] to prepend to your system message
     */
    fun prefix(color: TextColor, content: Component): Component =
        MiniMessage.miniMessage().deserialize(PREFIX,
            Placeholder.styling("prefix_color", color),
            Placeholder.component("prefix_content", content))

    /**
     * Returns a prefix for system messages, with a uniform format and color scheme for consistency
     * across plugins. The prefix is returned as a string in legacy chat format, with section chars.
     *
     * This overload sets the text inside the prefix to the message type (e.g. `Info` for
     * [MessageType.INFO]), and the prefix color is set according to the color scheme for the
     * message type (e.g. `red` for errors, `yellow` for warnings, etc.)
     *
     * @see Rosetta
     * @param type the type of system message
     * @return the prefix, as a string in legacy chat format, to prepend to your system message
     */
    fun legacyPrefix(type: MessageType): String =
        LegacyComponentSerializer.legacySection().serialize(prefix(type))

    /**
     * Returns a prefix for system messages, with a uniform format and color scheme for consistency
     * across plugins. The prefix is returned as a string in legacy chat format, with section chars.
     *
     * This overload accepts the text within the prefix (e.g. `Info`, `Success`, `Error`, etc.) in
     * MiniMessage format. The prefix color is set according to the color scheme for the message
     * type (e.g. `red` for errors, `yellow` for warnings, etc.)
     *
     * @see Rosetta
     * @param type the type of system message
     * @param content text to include within the prefix, e.g. Info, in MiniMessage format
     * @return the prefix, as a string in legacy chat format, to prepend to your system message
     */
    fun legacyPrefix(type: MessageType, content: String): String =
        LegacyComponentSerializer.legacySection().serialize(prefix(type, content))

    /**
     * Returns a prefix for system messages, with a uniform format and color scheme for consistency
     * across plugins. The prefix is returned as a string in legacy chat format, with section chars.
     *
     * This overload accepts the text within the prefix (e.g. `Info`, `Success`, `Error`, etc.) as
     * a [Component]. The prefix color is set according to the color scheme for the message type
     * (e.g. `red` for errors, `yellow` for warnings, etc.)
     *
     * @see Rosetta
     * @param type the type of system message
     * @param content text to include within the prefix, e.g. Info, as a [Component]
     * @return the prefix, as a string in legacy chat format, to prepend to your system message
     */
    fun legacyPrefix(type: MessageType, content: Component): String =
        LegacyComponentSerializer.legacySection().serialize(prefix(type, content))

    /**
     * Returns a prefix for system messages, with a uniform format and color scheme for consistency
     * across plugins. The prefix is returned as a string in legacy chat format, with section chars.
     *
     * This overload accepts the text within the prefix (e.g. `Info`, `Success`, `Error`, etc.) in
     * MiniMessage format, and the prefix color (e.g. `red` for errors, `yellow` for warnings, etc.)
     *
     * Note: Prefer using the [MessageType] functions over specifying your own colors, to enable
     * consistency across all system messages on the server.
     *
     * @see Rosetta
     * @param color the color of the prefix (should match the intent and content of the message)
     * @param content text to include within the prefix, e.g. Info, in MiniMessage format
     * @return the prefix, as a string in legacy chat format, to prepend to your system message
     */
    fun legacyPrefix(color: TextColor, content: String): String =
        LegacyComponentSerializer.legacySection().serialize(prefix(color, content))

    /**
     * Returns a prefix for system messages, with a uniform format and color scheme for consistency
     * across plugins. The prefix is returned as a string in legacy chat format, with section chars.
     *
     * This overload accepts the text within the prefix (e.g. `Info`, `Success`, `Error`, etc.) as
     * a [Component], and the prefix color (e.g. `red` for errors, `yellow` for warnings, etc.)
     *
     * Note: Prefer using the [MessageType] functions over specifying your own colors, to enable
     * consistency across all system messages on the server.
     *
     * @see Rosetta
     * @param color the color of the prefix (should match the intent and content of the message)
     * @param content text to include within the prefix, e.g. Info, as a [Component]
     * @return the prefix, as a string in legacy chat format, to prepend to your system message
     */
    fun legacyPrefix(color: TextColor, content: Component): String =
        LegacyComponentSerializer.legacySection().serialize(prefix(color, content))
}
